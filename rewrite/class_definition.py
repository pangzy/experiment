#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""class definition"""

from random import randint,expovariate
from math import ceil
from pulp import *
from xlrd import *
from global_variable import *

"""pause for debug"""
def pause():
	if raw_input("press any key to continue:"):
		pass

"""how to transfer time data from excel"""
def getTimeFromExcel(x):
	h = int(24*x)
	m = int(60*(24*x-h))
	s = int(60*(24*x-h)-m)

class Request(object):
	"""class for all Request,element in Request queue"""
	def __init__(self, T):
		self.at = OT			# arrival time
		self.ft = OT   			# finish time
		self.wt = 0				# waiting time
		self.size  = 0			# req data size 
		self.tsize = 0			# data size of req got in [0,T]
		self.psize = 0
		self.left  = 0 			# left size of req
		self.flag  = "hit"		# req category flag : miss,false,hit
		self.bdt   = OT  		# bdp,boundary timepoint
		self.idx   = 0  		# index in queue B
		self.b  = range(T)		# bandwidth for ri at timeslot t in queue_b
		self.debug_cb = range(T)
		self.debug_db = range(T)

		for t in xrange(T):
			self.b[t] = 0
			self.debug_cb[t] = 0
			self.debug_db[t] = 0

class ReqDataGenerator(object):
	"""------------------------------------------------------------------
	generator for req
	size distribution is a uniform random distribution
	the arrival events occur under a poisson distribution,
	so the arrival time of req is generated by a exponential distribution
	------------------------------------------------------------------"""
	def __init__(self):
		self.arrivalTime = []
		self.size = []
		self.n = 0

	def genReqArrivalTime(self,N,T,f=F,dis="poisson"):
		if dis=="poisson":
			print "\npoisson distribution."
			lamda = 1.0/f  						#the average rate of events per unit of time, lamda = N/T, req/sec
			ti = 0.0
			while True:
				ti += expovariate(lamda)
				if int(ti) >= T:
					break
				else:
					self.n+=1
					self.arrivalTime.append(int(ti))
		elif dis=="uniform":
			print "uniform random distribution."
			for i in xrange(N):
				self.arrivalTime.append(randint(0,T))
			self.arrivalTime.sort()
		else:
			print "wrong distribution."
			exit()

	def genReqSize(self,N,dis="poisson"):
		if dis=="poisson":
			if self.n == 0:
				print "No request in queue."
			else:
				for i in xrange(self.n):
					self.size.append(randint(MINS,MAXS))
		elif dis=="uniform":
			for i in xrange(N):
				self.size.append(randint(MINS,MAXS))
		else:
			print "wrong distribution."
			exit()

class ReqDataLoader(object):
	def __init__(self,TL):
		self.arrivalTime = []
		self.size    = []
		self.n       = 0
		self.tl 	 = TL
		self.tn 	 = 0
		self.t  	 = self.tn*self.tl

	def loadData(self):
		xlsFile  = open_workbook(DATAFILEPATH)
		table	 = xlsFile.sheet_by_index(1)
		timeData = table.col_values(1)
		sizeData = table.col_values(2)
		startRow = 514
		endRow	 = 636
		self.n	 = endRow-startRow+1
		startTime 	= int(timeData[startRow]*24)
		endTime 	= int(timeData[endRow]*24)+1
		self.tn 	= int(ceil((endTime-startTime)*3600/float(sefl.tl)))
		self.t  	= (endTime-startTime)*3600

		for i in range(startRow,endRow+1):
			t = int(timeData[i]*24*60*60) - startTime*60*60
			self.arrivalTime.append(t)
			s = int(ceil(sizeData[i]/1024))
			self.size.append(s)

class LPSolver(object):
	def __init__(self):
		pass

	def defProblem(self,rQueueA,rQueueB,N,T):
		iIdx = range(N)
		tIdx = range(T)
		ti 	 = range(N)
		si 	 = range(N)
		Ti   = range(N)
		Si   = range(N)

		for i in xrange(N):
			ti[i]	= rQueueA[i].at
			si[i]	= rQueueA[i].tsize
			Ti[i] 	= rQueueA[i].ft
			Si[i]	= rQueueA[i].size
			iIdx[i] = str(i)

		for t in xrange(T):
			tIdx[t] = str(t) 

		"""-----------------------------------
		PuLP variable definition
		varb--bi(t)
		prob--objective and constraints

		objective: 
			max:[0~N-1][0~ti-1])sigma bi(t)
		
		constraints: 
			1.any t,[0~N-1] sigma bi(t)   <= B
			2.any i,[0-Ti]  sigma bi(t)*TL>= si
			3.any i,[0~T-1] sigma bi(t)*TL<= Si
		------------------------------------"""
		print "\ndefine lp variables"
		self.varb = LpVariable.dicts('b',(iIdx,tIdx),0,B,cat='Integer')
		print "define lp problem"
		self.prob = LpProblem('Prefetching Schedule',LpMaximize)
		print "define lp objective"
		self.prob += lpSum([self.varb[i][t] for i in iIdx for t in tIdx if int(t)<ti[int(i)]])

		print "define constraints on B"
		for t in tIdx:
		 	self.prob += lpSum([self.varb[i][t] for i in iIdx])<=B

		print "define constraints on si"
		for i in iIdx:	
			self.prob += lpSum([self.varb[i][t] for t in tIdx if int(t)<=Ti[int(i)]]) >= ceil(float(si[int(i)])/TL)

		print "define constraints on Si"
		for i in iIdx:
			self.prob += lpSum([self.varb[i][t] for t in tIdx]) <= ceil(float(Si[int(i)])/TL)

	def solveProblem(self,solver="default"):
		if solver == "default" or solver == "":
			print "solve lp problem using default solver."
			self.probStatus = self.prob.solve()
		elif solver == "GLPK":
			print "solve lp problem using GLPK solver."
			glpkSolver = solvers.GLPK()
			self.probStatus = self.prob.solve(glpkSolver)
		else:
			print "wrong solver argument."
			exit()

		print "Problem solved. Status: "+LpStatus[self.probStatus]

	def exportData(self,rQueueB,N,T):
		for i in xrange(N):
			for t in xrange(T):
				rQueueB[i].b[t] = int(ceil(value(self.varb[str(i)][str(t)])))