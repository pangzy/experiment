#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""class definition"""

from random import randint,expovariate
from math import ceil
from pulp import *
from xlrd import *
from global_variable import *

"""pause for debug"""
def pause():
	if raw_input("press any key to continue:"):
		pass

"""how to transfer time data from excel"""
def getTimeFromExcel(x):
	h = int(24*x)
	m = int(60*(24*x-h))
	s = int(60*(24*x-h)-m)

class Request(object):
	"""class for all Request,element in Request queue"""
	def __init__(self, T):
		self.at = OT			# arrival time
		self.ft = OT   			# finish time
		self.wt = 0				# waiting time
		self.size = 0			# req data size 
		self.tsize = 0			# data size of req got in [0,T]
		self.left = 0 			# left size of req
		self.flag = HIT			# req category flag : MISS,FALSE,NORMAL
		self.ssize = 0			# suspend size
		self.st	= OT  			# suspend start
		self.se = OT  			# suspend end
		self.sindex = -1 		# suspend index
		self.b = range(T)		# bandwidth for ri at timeslot t in queue_b

		for t in xrange(T):
			self.b[t] = 0

class ReqDataGenerator(object):
	"""------------------------------------------------------------------
	generator for req
	size distribution is a uniform random distribution
	the arrival events occur under a poisson distribution,
	so the arrival time of req is generated by a exponential distribution
	------------------------------------------------------------------"""
	def __init__(self):
		self.arrivalTime = []
		self.size = []
		self.n = 0

	def genReqArrivalTime(self,T):
		lamda = 1.0/R  						#the average rate of events per unit of time, lamda = N/T, req/sec
		ti = 0.0

		while True:
			ti += expovariate(lamda)
			if int(ti) > T:
				break
			else:
				self.n+=1
				self.arrivalTime.append(int(ti))			
		#self.arrivalTime.sort()

	def genReqSize(self):
		if self.n == 0:
			print "No request in queue."
		else:
			for i in xrange(self.n):
				self.size.append(randint(MINS,MAXS))

class ReqDataLoader(object):
	def __init__(self,TL):
		self.arrivalTime = []
		self.size    = []
		self.n       = 0
		self.tl 	 = TL
		self.tn 	 = 0
		self.t  	 = self.tn*self.tl

	def loadData(self):
		xlsFile  = open_workbook(DATAFILEPATH)
		table	 = xlsFile.sheet_by_index(1)
		timeData = table.col_values(1)
		sizeData = table.col_values(2)
		startRow = 514
		endRow	 = 636
		self.n	 = endRow-startRow+1
		startTime 	= int(timeData[startRow]*24)
		endTime 	= int(timeData[endRow]*24)+1
		self.tn 	= int(ceil((endTime-startTime)*3600/float(sefl.tl)))
		self.t  	= (endTime-startTime)*3600

		for i in range(startRow,endRow+1):
			t = int(timeData[i]*24*60*60) - startTime*60*60
			self.arrivalTime.append(t)
			s = int(ceil(sizeData[i]/1024))
			self.size.append(s)

class LPSolver(object):
	def __init__(self):
		pass

	def defProblem(self,rQueueA,rQueueB,N,T):
		iIdx = range(N)
		tIdx = range(T)
		ti 	 = range(N)
		si 	 = range(N)
		Ti   = range(N)
		Si   = range(N)

		for i in xrange(N):
			ti[i]	= rQueueA[i].at
			si[i]	= rQueueA[i].tsize
			Ti[i] 	= rQueueA[i].ft
			Si[i]	= rQueueA[i].size
			iIdx[i] = str(i)

		for t in xrange(T):
			tIdx[t] = str(t) 

		"""-----------------------------------
		PuLP variable definition
		varb--bi(t)
		prob--objective and constraints

		objective: 
			max:[0~N-1][0~ti-1])sigma bi(t)
		
		constraints: 
			1.any t,[0~N-1] sigma bi(t)   <= B
			2.any i,[0-Ti]  sigma bi(t)*TL>= si
			3.any i,[0~T-1] sigma bi(t)*TL<= Si
		------------------------------------"""
		self.varb = LpVariable.dicts('b',(iIdx,tIdx),0,B,'Integer')
		self.prob = LpProblem('Prefetching Schedule',LpMaximize)

		self.prob += lpSum([self.varb[i][t] for i in iIdx for t in tIdx if int(t)<ti[int(i)]])

		for t in tIdx:
		 	self.prob += lpSum([self.varb[i][t] for i in iIdx])<=B

		for i in iIdx:	
			self.prob += lpSum([self.varb[i][t] for t in tIdx if int(t)<=Ti[int(i)]]) >= ceil(float(si[int(i)])/TL)

		for i in iIdx:
			self.prob += lpSum([self.varb[i][t] for t in tIdx]) <= 	ceil(float(Si[int(i)])/TL)

	def solveProblem(self):
		self.probStatus = self.prob.solve()

		print "Problem solved. Status: "+LpStatus[self.probStatus]

	def exportData(self,rQueueB,N,T):
		for i in xrange(N):
			for t in xrange(T):
				rQueueB[i].b[t] = int(ceil(value(self.varb[str(i)][str(t)])))